<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils/kekule.domHelper.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils/kekule.domHelper.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview
 * Generally we can use getElementsByTagName, getAttribute to analysis a DOM tree. If the
 * DOM has namespaces, getElementsByTagNameNS and getAttributeNS should be used instead.
 * However, IE (and MSXML) does not support those NS methods. So this file is trying to
 * provide a cross-browser solution.
 * @author Partridge Jiang
 */

/*
 * requires /lan/classes.js
 * requires /core/kekule.common.js
 * requires /localization/
 */

/**
 * DOM helper to help to analysis DOM trees (especially with namespaces).
 * @class
 * @augments ObjectEx
 * @param {Object} doc A HTML or XML document.
 *
 * @property {Object} document Document of current DOM tree. Either rootElement or document must be set before utilize this class.
 * @property {Object} rootElement Root element of DOM. Either rootElement or document must be set before utilize this class.
 * @property {Array} namespaces Namespaces of current document.
 *   Each items in array has two fields: {namespaceURI, prefix}.
 * @property {String} defNamespaceURI Default namespace URI of document.
 * @property {Bool} forceAnalysisDoc If NS methods is supported by browser, analysis of document
 *   is not essential. However, if turn this property to true, the analysis process will still execute.
 */
Kekule.DomHelper = Class.create(ObjectEx,
/** @lends Kekule.DomHelper# */
{
	/** @private */
	CLASS_NAME: 'Kekule.DomHelper',
	/** @private */
	NAMESPACE_DEFINE_PREFIX: 'xmlns',
	/** @private */
	NAMESPACE_DELIMITER: ':',
	/** @private */
	ERR_EMPTY_DOC: 'Document is empty',
	/** @private */
	ERR_ELEMENT_NOTSET: 'Element not set',
	/** @constructs */
	initialize: function($super, doc)
	{
		$super();
		this._supportNsMethods = null;
		if (doc)
			this.setDocument(doc);
	},
	/** @private */
	initProperties: function()
	{
		this.defineProp('document', {
			'dataType': DataType.OBJECT,
			'serializable': false,
			'getter': function()
				{
					var result = this.getPropStoreFieldValue('document');
					if (!result)
					{
						var elem = this.getPropStoreFieldValue('rootElement');
						result = elem? elem.ownerDocument: null;
					}
					return result;
				},
			'setter': function(value)
				{
					if (value != this.getPropStoreFieldValue('document'))
					{
						this.setPropStoreFieldValue('document', value);
						this.analysisRootElem();
					}
				}
		});
		this.defineProp('rootElement', {
			'dataType': DataType.OBJECT,
			'serializable': false,
			'getter': function()
				{
					var result = this.getPropStoreFieldValue('rootElement');
					if (!result)
					{
						var doc = this.getPropStoreFieldValue('document');
						result = doc? doc.documentElement: null;
					}
					return result;
				},
			'setter': function(value)
				{
					this.setPropStoreFieldValue('rootElement', value);
					this.analysisRootElem();
				}
		});
		this.defineProp('namespaces', {
			'dataType': DataType.ARRAY,
			'serializable': false,
			'getter': function()
				{
					if (!this.getPropStoreFieldValue('namespaces'))
						this.setPropStoreFieldValue('namespaces', []);
					return this.getPropStoreFieldValue('namespaces')
				}
			});
		this.defineProp('defNamespaceURI', {'dataType': DataType.STRING, 'serializable': false});
		this.defineProp('forceAnalysisDoc', {'dataType': DataType.BOOL});
	},

	/**
	 * Analysis document and get basic namespace informations (mainly on documentElement).
	 * @private
	 */
	analysisRootElem: function()
	{
		this.setNamespaces([]);
		this.setDefNamespaceURI(null);
		/*
		var doc = this.getDocument();
		if (!doc)
			return;
		*/
		var docElem = this.getRootElement();
		if (!docElem)
			return;

		var doc = docElem.ownerDocument;
		// detect if browser support NS methods. IE will be false.
		this._supportNsMethods = !!doc.getElementsByTagNameNS;

		if ((!this._supportNsMethods) || (this.getForceAnalysisDoc()))
		{
			// check all docElem's attributes
			//var docElem = doc.documentElement;
			for (var i = 0, l = docElem.attributes.length; i &lt; l; ++i)
			{
				var attrib = docElem.attributes[i];
				var attribName = attrib.name;
				if (attribName &amp;&amp; attribName.indexOf(this.NAMESPACE_DEFINE_PREFIX) >= 0) // an namespace item
				{
					var ns = attrib.value;
					var delimiterPos = attribName.indexOf(this.NAMESPACE_DELIMITER);
					var prefix = (delimiterPos >= 0) ? attribName.substring(delimiterPos + 1) : null;
					this.getNamespaces().push({
						'namespaceURI': ns,
						'prefix': prefix
					});
					if (!prefix)
						this.setDefNamespaceURI(ns);
				}
			}
		}
	},

	/** @private */
	_getEmptyDocErrorMsg: function()
	{
		return !Kekule.hasLocalRes()? this.ERR_EMPTY_DOC: Kekule.$L('ErrorMsg.EMPTY_DOC'); //Kekule.ErrorMsg.EMPTY_DOC;
	},
	/** @private */
	_getElementNotSetErrorMsg: function()
	{
		return !Kekule.hasLocalRes()? this.ELEMENT_NOTSET: Kekule.$L('ErrorMsg.ELEMENT_NOTSET'); //Kekule.ErrorMsg.ELEMENT_NOTSET;
	},

	/** @private */
	assertDocAvailable: function(doc)
	{
		if (!doc)
		{
			Kekule.raise(this._getEmptyDocErrorMsg());
			return false;
		}
		else
			return true;
	},
	/** @private */
	assertElementAvailable: function(element)
	{
		if (!element)
		{
			Kekule.raise(this._getElementNotSetErrorMsg());
			return false;
		}
		else
			return true;
	},

	/**
	 * Get prefix of namespace in current document.
	 * @param {Object} namespaceURI
	 * @returns {String}
	 */
	getNsPrefix: function(namespaceURI)
	{
		if (namespaceURI == this.getDefNamespaceURI())
			return '';
		var namespaces = this.getNamespaces();
		for (var i = 0, l = namespaces.length; i &lt; l; ++i)
		{
			if (namespaces[i].namespaceURI == namespaceURI)
				return namespaces[i].prefix;
		}
		return null;
	},
	/**
	 * Get qualified name (prefix:localName) of tag.
	 * @param {String} namespaceURI
	 * @param {String} localName
	 * @returns {String} Qualified name or null on fail.
	 */
	getQualifiedName: function(namespaceURI, localName)
	{
		var prefix = this.getNsPrefix(namespaceURI);
		if (prefix === null)  // prefix not found, namespace URI not exists
			return null;
		else
			return prefix? prefix + this.NAMESPACE_DELIMITER + localName: localName;
	},

	/**
	 * Create an element with namespace in current document.
	 * @param {String} namespace Namespace of the new element.
	 * @param {String} qualifiedName Qualified name (e.g. myns:element) of the element to create.
	 * @returns {Object} Element created or null on failed.
	 */
	createElementNS: function(namespace, qualifiedName)
	{
		var doc = this.getDocument();
		if (!this.assertDocAvailable(doc))
			return null;

		if (this._supportNsMethods)
			return doc.createElementNS(namespace, qualifiedName);
		else
		{
			// the qualifiedName still has a prefix, so create it alone seems to work either
			return doc.createElement(qualifiedName);
		}
	},

	/**
	 * Get all elements by name in namespace. If param element is not set, it is similar to
	 *   call document.getElementsByTagNameNS or rootElement.getElementsByTagNameNS,
	 *   otherwise element.getElementsByTagName.
	 * Note: here we do not support '*' for localname.
	 * @param {String} namespaceURI
	 * @param {String} localName
	 * @param {Object} element
	 * @returns {Array} Elements found or null on failed.
	 */
	getElementsByTagNameNS: function(namespaceURI, localName, element)
	{
		var root = this.getPropStoreFieldValue('document') || this.getPropStoreFieldValue('rootElement');
		var doc = this.getDocument();
		if (!this.assertDocAvailable(doc))
			return null;

		if (this._supportNsMethods)
		{
			if (element)
				return element.getElementsByTagNameNS(namespaceURI, localName);
			else
				return root.getElementsByTagNameNS(namespaceURI, localName);
		}
		else
		{
			var qualifiedName = this.getQualifiedName(namespaceURI, localName);
			if (qualifiedName === null)  // qualifiedName not available, namespace URI not exists
			{
				return [];
			}
			else
			{
				if (element)
					return element.getElementsByTagName(qualifiedName);
				else
					return root.getElementsByTagName(qualifiedName);
			}
		}
	},

	/**
	 * Element.getAttributeNodeNS
	 * @param {String} namespaceURI
	 * @param {String} localName
	 * @param {Object} element
	 * @returns {Object} Attribute node or null.
	 */
	getAttributeNodeNS: function(namespaceURI, localName, element)
	{
		if (!this.assertElementAvailable(element))
			return null;
		if (this._supportNsMethods)
			return element.getAttributeNodeNS(namespaceURI, localName);
		else
		{
			var qualifiedName = this.getQualifiedName(namespaceURI, localName);
			if (qualifiedName === null)  // qualifiedName not available, namespace URI not exists
			{
				return null;
			}
			else
			{
				return element.getAttributeNode(qualifiedName);
			}
		}
	},

	/**
	 * Element.getAttributeNS
	 * @param {String} namespaceURI
	 * @param {String} localName
	 * @param {Object} element
	 * @returns {String} Attribute value or null.
	 */
	getAttributeNS: function(namespaceURI, localName, element)
	{
		if (!this.assertElementAvailable(element))
			return null;
		if (this._supportNsMethods)
			return element.getAttributeNS(namespaceURI, localName);
		else
		{
			var qualifiedName = this.getQualifiedName(namespaceURI, localName);
			if (qualifiedName === null)  // qualifiedName not available, namespace URI not exists
			{
				return null;
			}
			else
			{
				return element.getAttribute(qualifiedName);
			}
		}
	},

	/**
	 * Element.setAttributeNS
	 * @param {String} namespaceURI
	 * @param {String} localName
	 * @param {String} value
	 * @param {Object} element
	 */
	setAttributeNS: function(namespaceURI, localName, value, element)
	{
		if (!this.assertElementAvailable(element))
			return null;
		if (this._supportNsMethods)
			return element.setAttributeNS(namespaceURI, localName, value);
		else
		{
			var qualifiedName = this.getQualifiedName(namespaceURI, localName);
			if (qualifiedName === null)  // qualifiedName not available, namespace URI not exists
			{
				return null;
			}
			else
			{
				return element.setAttribute(qualifiedName, value);
			}
		}
	}
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="Class.html">Class</a></li><li><a href="ClassEx.html">ClassEx</a></li><li><a href="JsonObjSerializer.html">JsonObjSerializer</a></li><li><a href="Kekule.AbstractAtom.html">AbstractAtom</a></li><li><a href="Kekule.AbstractConfigs.html">AbstractConfigs</a></li><li><a href="Kekule.ArrayUtils.html">ArrayUtils</a></li><li><a href="Kekule.Atom.html">Atom</a></li><li><a href="Kekule.AtomType.html">AtomType</a></li><li><a href="Kekule.BaseStructureConnector.html">BaseStructureConnector</a></li><li><a href="Kekule.BaseStructureNode.html">BaseStructureNode</a></li><li><a href="Kekule.Bond.html">Bond</a></li><li><a href="Kekule.BondForm.html">BondForm</a></li><li><a href="Kekule.BondFormFactory.html">BondFormFactory</a></li><li><a href="Kekule.BondOrder.html">BondOrder</a></li><li><a href="Kekule.BondStereo.html">BondStereo</a></li><li><a href="Kekule.BondType.html">BondType</a></li><li><a href="Kekule.BoxUtils.html">BoxUtils</a></li><li><a href="Kekule.ChemMarker.BaseMarker.html">BaseMarker</a></li><li><a href="Kekule.ChemMarker.Charge.html">Charge</a></li><li><a href="Kekule.ChemMarker.ChemPropertyMarker.html">ChemPropertyMarker</a></li><li><a href="Kekule.ChemMarker.Radical.html">Radical</a></li><li><a href="Kekule.ChemMarker.UnbondedElectronSet.html">UnbondedElectronSet</a></li><li><a href="Kekule.ChemStructureBuilder.html">ChemStructureBuilder</a></li><li><a href="Kekule.ChemStructureConnector.html">ChemStructureConnector</a></li><li><a href="Kekule.ChemStructureNode.html">ChemStructureNode</a></li><li><a href="Kekule.ChemStructureNodeFactory.html">ChemStructureNodeFactory</a></li><li><a href="Kekule.ChemStructureNodeLabels.html">ChemStructureNodeLabels</a></li><li><a href="Kekule.ChemStructureObjectGroup.html">ChemStructureObjectGroup</a></li><li><a href="Kekule.ChemStructureUtils.html">ChemStructureUtils</a></li><li><a href="Kekule.ChemTextAnalyzer.html">ChemTextAnalyzer</a></li><li><a href="Kekule.ClassUtils.html">ClassUtils</a></li><li><a href="Kekule.CompositeMolecule.html">CompositeMolecule</a></li><li><a href="Kekule.ConfigPresetMap.html">ConfigPresetMap</a></li><li><a href="Kekule.ContentBlock.html">ContentBlock</a></li><li><a href="Kekule.CoordUtils.html">CoordUtils</a></li><li><a href="Kekule.DomHelper.html">DomHelper</a></li><li><a href="Kekule.ElectronSet.html">ElectronSet</a></li><li><a href="Kekule.Element.html">Element</a></li><li><a href="Kekule.FactoryUtils.html">FactoryUtils</a></li><li><a href="Kekule.FormulaUtils.html">FormulaUtils</a></li><li><a href="Kekule.GeometryUtils.html">GeometryUtils</a></li><li><a href="Kekule.Glyph.AddSymbol.html">AddSymbol</a></li><li><a href="Kekule.Glyph.Arc.html">Arc</a></li><li><a href="Kekule.Glyph.ArrowSide.html">ArrowSide</a></li><li><a href="Kekule.Glyph.ArrowType.html">ArrowType</a></li><li><a href="Kekule.Glyph.Base.html">Base</a></li><li><a href="Kekule.Glyph.HeatSymbol.html">HeatSymbol</a></li><li><a href="Kekule.Glyph.NodeType.html">NodeType</a></li><li><a href="Kekule.Glyph.PathGlyph.html">PathGlyph</a></li><li><a href="Kekule.Glyph.PathGlyphArcConnector.html">PathGlyphArcConnector</a></li><li><a href="Kekule.Glyph.PathGlyphArcConnectorControlNode.html">PathGlyphArcConnectorControlNode</a></li><li><a href="Kekule.Glyph.PathGlyphConnector.html">PathGlyphConnector</a></li><li><a href="Kekule.Glyph.PathGlyphConnectorControlNode.html">PathGlyphConnectorControlNode</a></li><li><a href="Kekule.Glyph.PathGlyphNode.html">PathGlyphNode</a></li><li><a href="Kekule.Glyph.PathType.html">PathType</a></li><li><a href="Kekule.Glyph.Polygon.html">Polygon</a></li><li><a href="Kekule.Glyph.StraightLine.html">StraightLine</a></li><li><a href="Kekule.HybridizationType.html">HybridizationType</a></li><li><a href="Kekule.ImageBlock.html">ImageBlock</a></li><li><a href="Kekule.Isotope.html">Isotope</a></li><li><a href="Kekule.IsotopeFactory.html">IsotopeFactory</a></li><li><a href="Kekule.MatrixUtils.html">MatrixUtils</a></li><li><a href="Kekule.MolecularFormula.html">MolecularFormula</a></li><li><a href="Kekule.Molecule.html">Molecule</a></li><li><a href="Kekule.MoleculeGroup.html">MoleculeGroup</a></li><li><a href="Kekule.MoleculeList.html">MoleculeList</a></li><li><a href="Kekule.NumUtils.html">NumUtils</a></li><li><a href="Kekule.ObjUtils.html">ObjUtils</a></li><li><a href="Kekule.PredefinedResLoader.html">PredefinedResLoader</a></li><li><a href="Kekule.PredefinedResReferer.html">PredefinedResReferer</a></li><li><a href="Kekule.Pseudoatom.html">Pseudoatom</a></li><li><a href="Kekule.PseudoatomType.html">PseudoatomType</a></li><li><a href="Kekule.RadicalOrder.html">RadicalOrder</a></li><li><a href="Kekule.Reaction.html">Reaction</a></li><li><a href="Kekule.ReactionComponent.html">ReactionComponent</a></li><li><a href="Kekule.ReactionList.html">ReactionList</a></li><li><a href="Kekule.ReactionRole.html">ReactionRole</a></li><li><a href="Kekule.RectUtils.html">RectUtils</a></li><li><a href="Kekule.RoleMapUtils.html">RoleMapUtils</a></li><li><a href="Kekule.StructureConnectionTable.html">StructureConnectionTable</a></li><li><a href="Kekule.StructureFragment.html">StructureFragment</a></li><li><a href="Kekule.StructureFragmentGroup.html">StructureFragmentGroup</a></li><li><a href="Kekule.StructureFragmentShadow.html">StructureFragmentShadow</a></li><li><a href="Kekule.StrUtils.html">StrUtils</a></li><li><a href="Kekule.SubGroup.html">SubGroup</a></li><li><a href="Kekule.TextBlock.html">TextBlock</a></li><li><a href="Kekule.TextLinesBuffer.html">TextLinesBuffer</a></li><li><a href="Kekule.TokenAnalyzer.html">TokenAnalyzer</a></li><li><a href="Kekule.UnbondedElectronSet.html">UnbondedElectronSet</a></li><li><a href="Kekule.ValenceUtils.html">ValenceUtils</a></li><li><a href="Kekule.VariableAtom.html">VariableAtom</a></li><li><a href="Kekule.ZoomUtils.html">ZoomUtils</a></li><li><a href="ObjectEx.html">ObjectEx</a></li><li><a href="ObjSerializerFactory.html">ObjSerializerFactory</a></li><li><a href="XmlObjSerializer.html">XmlObjSerializer</a></li><li><a href="XmlUtility.html">XmlUtility</a></li></ul><h3>Events</h3><ul><li><a href="Kekule.AbstractAtom.html#event:structureChange">structureChange</a></li><li><a href="Kekule.AbstractConfigs.html#event:change">change</a></li><li><a href="Kekule.AbstractConfigs.html#event:finalize">finalize</a></li><li><a href="Kekule.AbstractConfigs.html#event:propValueSet">propValueSet</a></li><li><a href="Kekule.Atom.html#event:structureChange">structureChange</a></li><li><a href="Kekule.BaseStructureConnector.html#event:structureChange">structureChange</a></li><li><a href="Kekule.BaseStructureNode.html#event:structureChange">structureChange</a></li><li><a href="Kekule.Bond.html#event:structureChange">structureChange</a></li><li><a href="Kekule.ChemStructureBuilder.html#event:change">change</a></li><li><a href="Kekule.ChemStructureBuilder.html#event:finalize">finalize</a></li><li><a href="Kekule.ChemStructureBuilder.html#event:propValueSet">propValueSet</a></li><li><a href="Kekule.ChemStructureConnector.html#event:structureChange">structureChange</a></li><li><a href="Kekule.ChemStructureNode.html#event:structureChange">structureChange</a></li><li><a href="Kekule.ChemStructureObject.html#event:structureChange">structureChange</a></li><li><a href="Kekule.ChemStructureObjectGroup.html#event:structureChange">structureChange</a></li><li><a href="Kekule.ChemTextAnalyzer.html#event:change">change</a></li><li><a href="Kekule.ChemTextAnalyzer.html#event:finalize">finalize</a></li><li><a href="Kekule.ChemTextAnalyzer.html#event:propValueSet">propValueSet</a></li><li><a href="Kekule.CompositeMolecule.html#event:structureChange">structureChange</a></li><li><a href="Kekule.ConfigPresetMap.html#event:change">change</a></li><li><a href="Kekule.ConfigPresetMap.html#event:finalize">finalize</a></li><li><a href="Kekule.ConfigPresetMap.html#event:propValueSet">propValueSet</a></li><li><a href="Kekule.DomHelper.html#event:change">change</a></li><li><a href="Kekule.DomHelper.html#event:finalize">finalize</a></li><li><a href="Kekule.DomHelper.html#event:propValueSet">propValueSet</a></li><li><a href="Kekule.Glyph.PathGlyphArcConnector.html#event:structureChange">structureChange</a></li><li><a href="Kekule.Glyph.PathGlyphArcConnectorControlNode.html#event:structureChange">structureChange</a></li><li><a href="Kekule.Glyph.PathGlyphConnector.html#event:structureChange">structureChange</a></li><li><a href="Kekule.Glyph.PathGlyphConnectorControlNode.html#event:structureChange">structureChange</a></li><li><a href="Kekule.Glyph.PathGlyphNode.html#event:structureChange">structureChange</a></li><li><a href="Kekule.MolecularFormula.html#event:change">change</a></li><li><a href="Kekule.MolecularFormula.html#event:finalize">finalize</a></li><li><a href="Kekule.MolecularFormula.html#event:propValueSet">propValueSet</a></li><li><a href="Kekule.Molecule.html#event:structureChange">structureChange</a></li><li><a href="Kekule.MoleculeGroup.html#event:structureChange">structureChange</a></li><li><a href="Kekule.PredefinedResLoader.html#event:change">change</a></li><li><a href="Kekule.PredefinedResLoader.html#event:finalize">finalize</a></li><li><a href="Kekule.PredefinedResLoader.html#event:propValueSet">propValueSet</a></li><li><a href="Kekule.Pseudoatom.html#event:structureChange">structureChange</a></li><li><a href="Kekule.StructureConnectionTable.html#event:change">change</a></li><li><a href="Kekule.StructureConnectionTable.html#event:finalize">finalize</a></li><li><a href="Kekule.StructureConnectionTable.html#event:propValueSet">propValueSet</a></li><li><a href="Kekule.StructureFragment.html#event:structureChange">structureChange</a></li><li><a href="Kekule.StructureFragmentGroup.html#event:structureChange">structureChange</a></li><li><a href="Kekule.StructureFragmentShadow.html#event:change">change</a></li><li><a href="Kekule.StructureFragmentShadow.html#event:finalize">finalize</a></li><li><a href="Kekule.StructureFragmentShadow.html#event:propValueSet">propValueSet</a></li><li><a href="Kekule.SubGroup.html#event:structureChange">structureChange</a></li><li><a href="Kekule.TextLinesBuffer.html#event:change">change</a></li><li><a href="Kekule.TextLinesBuffer.html#event:finalize">finalize</a></li><li><a href="Kekule.TextLinesBuffer.html#event:propValueSet">propValueSet</a></li><li><a href="Kekule.TokenAnalyzer.html#event:change">change</a></li><li><a href="Kekule.TokenAnalyzer.html#event:finalize">finalize</a></li><li><a href="Kekule.TokenAnalyzer.html#event:propValueSet">propValueSet</a></li><li><a href="Kekule.VariableAtom.html#event:structureChange">structureChange</a></li><li><a href="ObjectEx.html#event:change">change</a></li><li><a href="ObjectEx.html#event:finalize">finalize</a></li><li><a href="ObjectEx.html#event:propValueSet">propValueSet</a></li></ul><h3>Namespaces</h3><ul><li><a href="Kekule.ChemMarker.html">ChemMarker</a></li><li><a href="Kekule.Glyph.html">Glyph</a></li></ul><h3>Global</h3><ul><li><a href="global.html#jsonToValue">jsonToValue</a></li><li><a href="global.html#loadObj">loadObj</a></li><li><a href="global.html#saveObj">saveObj</a></li><li><a href="global.html#valueToJson">valueToJson</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-dev</a> on Mon Nov 26 2018 21:08:32 GMT+0800 (CST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
