<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: chemdoc/kekule.attachedMarkers.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: chemdoc/kekule.attachedMarkers.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview
 * Implementation of property markers (e.g. charge mark, lone pair, etc.) binding to the chem object.
 * @author Partridge Jiang
 */

/*
 * requires /lan/classes.js
 * requires /core/kekule.common.js
 * requires /core/kekule.structures.js
 * requires /core/kekule.chemUtils.js
 */

(function(){
"use strict";

var AU = Kekule.ArrayUtils;

/**
 * A recommended namespace for all attach marker classes
 * @namespace
 */
Kekule.ChemMarker = {};

// extend chemObject, enable associate descriptive glyphs to it
/** @ignore */
ClassEx.extend(Kekule.ChemObject,
/** @lends Kekule.ChemObject# */
{
	/**
	 * Returns whether current object is an attachedMarker of parent object.
	 * @returns {Bool}
	 */
	isAttachedMarker: function()
	{
		var p = this.getParent();
		return (p &amp;&amp; p.hasMarker(this));
	},
	/**
	 * Notify {@link Kekule.ChemObject#attachedMarkers} property has been changed
	 * @private
	 */
	notifyAttachedMarkersChanged: function()
	{
		this.notifyPropSet('attachedMarkers', this.getPropStoreFieldValue('attachedMarkers'));
	},
	/** @private */
	_attachedMarkerAdded: function(marker)
	{
		// do nothing here
	},
	/** @private */
	_attachedMarkerRemoved: function(marker)
	{
		// do nothing here
	},

	/**
	 * Return count of attached markers.
	 * @returns {Int}
	 */
	getMarkerCount: function()
	{
		var markers = this.getPropStoreFieldValue('attachedMarkers');
		return markers? markers.length: 0;
	},
	/**
	 * Get attached marker at index.
	 * @param {Int} index
	 * @returns {Kekule.ChemObject}
	 */
	getMarkerAt: function(index)
	{
		var markers = this.getPropStoreFieldValue('attachedMarkers');
		return markers? markers[index]: null;
	},
	/**
	 * Returns the first child marker of a specified class type.
	 * @param {Class} classType
	 * @param {Bool} exactMatch If true, only marker of classType (not its descendants) should be returned.
	 * @returns {Kekule.ChemObject}
	 */
	getMarkerOfType: function(classType, exactMatch)
	{
		for (var i = 0, l = this.getMarkerCount(); i &lt; l; ++i)
		{
			var marker = this.getMarkerAt(i);
			if ((exactMatch &amp;&amp; marker.getClass() === classType) || (marker instanceof classType))
				return marker;
		}
		return null;
	},
	/**
	 * Returns all child markers of a specified class type.
	 * @param {Class} classType
	 * @param {Bool} exactMatch If true, only markers of classType (not its descendants) should be returned.
	 * @returns {Array}
	 */
	getMarkersOfType: function(classType, exactMatch)
	{
		var result = [];
		for (var i = 0, l = this.getMarkerCount(); i &lt; l; ++i)
		{
			var marker = this.getMarkerAt(i);
			if ((exactMatch &amp;&amp; marker.getClass() === classType) || (marker instanceof classType))
				result.push(marker);
		}
		return result;
	},
	/**
	 * Get attached marker of classType. If no such a marker currently and canCreate is true, a new marker will be created.
	 * @param {Class} classType
	 * @param {Bool} canCreate
	 * @param {Bool} exactMatch If true, only marker of classType (not its descendants) should be returned.
	 * @param {Hash} defProps If create a new marker, those prop values will be applied.
	 * @returns {Kekule.ChemObject}
	 */
	fetchMarkerOfType: function(classType, canCreate, exactMatch, defProps)
	{
		var result = this.getMarkerOfType(classType, exactMatch);
		if (!result &amp;&amp; canCreate)
		{
			result = new classType();
			result.beginUpdate();
			try
			{
				if (defProps)
				{
					result.setPropValues(defProps);
				}
				//console.log('fetch create on', this.getId());
				this.appendMarker(result);
			}
			finally
			{
				result.endUpdate();
			}
		}
		return result;
	},
	/**
	 * Returns markers that has no coord on coordMode
	 * @param {Int} coordMode
	 * @return {Array}
	 */
	getUnplacedMarkers: function(coordMode)
	{
		var result = [];
		for (var i = 0, l = this.getMarkerCount(); i &lt; l; ++i)
		{
			var marker = this.getMarkerAt(i);
			if (!marker.getCoordOfMode(coordMode))
				result.push(marker);
		}
		return result;
	},
	/**
	 * Get index of attached marker in marker array.
	 * @param {Kekule.ChemObject} marker
	 * @returns {Int}
	 */
	indexOfMarker: function(marker)
	{
		var markers = this.getPropStoreFieldValue('attachedMarkers');
		return markers? markers.indexOf(marker): -1;
	},
	/**
	 * Check if a marker has been attached to this object.
	 * @param {Kekule.ChemObject} marker
	 * @returns {Bool}
	 */
	hasMarker: function(marker)
	{
		return this.indexOfMarker(marker) >= 0;
	},
	/**
	 * Returns whether there exists child markers of a specified class type.
	 * @param {Class} classType
	 * @param {Bool} exactMatch If true, only markers of classType (not its descendants) should be considered.
	 * @returns {Bool}
	 */
	hasMarkerOfType: function(classType, exactMatch)
	{
		return !!this.getMarkerOfType(classType, exactMatch);
	},
	/**
	 * Attach a marker to this object. If marker already exists, nothing will be done.
	 * @param {Kekule.ChemObject} marker
	 */
	appendMarker: function(marker)
	{
		var index = this.indexOfMarker(marker);
		if (index >= 0) // already exists
			return index;// do nothing
		else
		{
			var result = this.getAttachedMarkers(true).push(marker);
			marker.beginUpdate();
			try
			{
				if (marker.setOwner)
					marker.setOwner(this.getOwner());
				if (marker.setParent)
					marker.setParent(this);
				this._attachedMarkerAdded(marker);
			}
			finally
			{
				marker.endUpdate();
			}
			this.notifyAttachedMarkersChanged();
			return result;
		}
	},
	/**
	 * Insert marker before refMarker in marker list. If refMarker is null or does not exists, marker will be append to tail of list.
	 * @param {Kekule.ChemObject} marker
	 * @param {Kekule.ChemObject} refMarker
	 * @return {Int} Index of obj after inserting.
	 */
	insertMarkerBefore: function(marker, refMarker)
	{
		var refIndex = this.indexOfMarker(refMarker);
		return this.insertMarkerAt(marker, refIndex);
	},
	/**
	 * Insert marker to index. If index is not set, marker will be inserted to the tail of the marker array.
	 * @param {Kekule.ChemObject} marker
	 * @param {Int} index
	 */
	insertMarkerAt: function(marker, index)
	{
		var i = this.indexOfMarker(marker);
		var markers = this.getAttachedMarkers(true);
		if (Kekule.ObjUtils.isUnset(index) || (index &lt; 0))
			index = markers.length;
		if (i >= 0)  // already inside, adjust position
		{
			markers.splice(i, 1);
			markers.splice(index, 0, marker);
		}
		else // new one
		{
			markers.splice(index, 0, marker);
			if (marker.setOwner)
				marker.setOwner(this.getOwner());
			if (marker.setParent)
				marker.setParent(this);
			this._attachedMarkerAdded(marker);
		}
		this.notifyAttachedMarkersChanged();
		return index;
	},
	/**
	 * Change index of marker.
	 * @param {Kekule.ChemObject} marker
	 * @param {Int} index
	 */
	setMarkerIndex: function(marker, index)
	{
		var i = this.indexOfMarker(marker);
		if (i >= 0)  // already inside, adjust position
		{
			var markers = this.getPropStoreFieldValue('attachedMarkers'); // this.getAttachedMarkers();
			markers.splice(i, 1);
			markers.splice(index, 0, marker);
		}
	},
	/**
	 * Remove marker at index in attached marker list.
	 * @param {Int} index
	 */
	removeMarkerAt: function(index)
	{
		var marker = this.getMarkerAt(index);
		if (marker)
		{
			var result = this.getAttachedMarkers(true).splice(index, 1);
			if (marker.setOwner)
				marker.setOwner(null);
			if (marker.setParent)
				marker.setParent(null);
			this._attachedMarkerRemoved(marker);
			this.notifyAttachedMarkersChanged();
			return result;
		}
	},
	/**
	 * Remove an attached marker.
	 * @param {Kekule.ChemObject} marker
	 */
	removeMarker: function(marker)
	{
		var index = this.indexOfMarker(marker);
		if (index >= 0)
			return this.removeMarkerAt(index);
	},
	/**
	 * Replace oldMarker with new one.
	 * @param {Kekule.ChemObject} oldMarker
	 * @param {Kekule.ChemObject} newMarker
	 */
	replaceMarker: function(oldMarker, newMarker)
	{
		var oldIndex = this.indexOfMarker(oldMarker);
		if (oldIndex &lt; 0)  // old marker not exists
		{
			return this;
		}
		else
		{
			this.removeMarkerAt(oldIndex);
			this.insertMarkerAt(newMarker, oldIndex);
			return this;
		}
	},
	/**
	 * Remove all attached markers.
	 */
	clearMarkers: function()
	{
		//var oldMarkers = AU.clone(this.getAttachedMarkers());
		var oldMarkers = this.getPropStoreFieldValue('attachedMarkers');
		if (oldMarkers)
			oldMarkers = AU.clone(oldMarkers);

		this.setPropStoreFieldValue('attachedMarkers', null);

		if (oldMarkers)
		{
			for (var i = 0, l = oldMarkers.length; i &lt; l; ++i)
			{
				var marker = oldMarkers[i];
				if (marker.setOwner)
					marker.setOwner(null);
				if (marker.setParent)
					marker.setParent(null);
				this._attachedMarkerRemoved(marker);
			}
		}

		this.notifyAttachedMarkersChanged();
		return this;
	},

	autoSetMarker2DPos: function(marker, offset, allowCoordBorrow, avoidDirectionAngles)
	{
		if (this.hasMarker(marker))
		{
			var angle = Kekule.ChemStructureUtils.getMostEmptyDirection2DAngleOfObj(this, [marker], allowCoordBorrow, true, false, avoidDirectionAngles);
			var coord = {'x': offset * Math.cos(angle), 'y': offset * Math.sin(angle)};
			//console.log('angle2', coord);
			marker.setCoord2D(coord);
		}
	},

	/** @private */
	_updateAttachedMarkersOwner: function(owner)
	{
		if (!owner)
			owner = this.getOwner();
		for (var i = 0, l = this.getMarkerCount(); i &lt; l; ++i)
		{
			var marker = this.getMarkerAt(i);
			if (marker.setOwner)
				marker.setOwner(owner);
		}
	},
	/** @private */
	_updateAttachedMarkersParent: function(parent)
	{
		if (!parent)
			parent = this;
		/*
		if (this.getMarkerCount() > 0)
			console.log('set parent', parent.getClassName());
    */
		for (var i = 0, l = this.getMarkerCount(); i &lt; l; ++i)
		{
			var marker = this.getMarkerAt(i);
			if (marker.setParent)
				marker.setParent(parent);
		}
	}
});
ClassEx.extendMethod(Kekule.ChemObject, 'ownerChanged', function($origin, newOwner){
	$origin(newOwner);
	this._updateAttachedMarkersOwner(newOwner);
});
ClassEx.extendMethod(Kekule.ChemObject, 'removeChild', function($origin, child){
	//console.log('remove child', child.getClassName(), child.getId());
	var result = $origin(child);
	if (!result)
		result = this.removeMarker(child) || $origin(child);
	return result;
});
ClassEx.extendMethod(Kekule.ChemObject, 'insertBefore', function($origin, child, refChild){
	var result = $origin(child, refChild);
	if (result &lt; 0)
	{
		if (refChild &amp;&amp; this.hasMarker(refChild) || child instanceof Kekule.ChemMarker.BaseMarker)
			result = this.insertMarkerBefore(child, refChild);
	}
	return result;
});

ClassEx.defineProp(Kekule.ChemObject, 'attachedMarkers',
{
	'dataType': DataType.ARRAY, 'scope':  Class.PropertyScope.PUBLISHED,
	'getter': function(autoCreate)
	{
		var result = this.getPropStoreFieldValue('attachedMarkers');
		if (!result &amp;&amp; autoCreate)
		{
			result = [];
			this.setPropStoreFieldValue('attachedMarkers', result);
		}
		return result;
	},
	'setter': function(value)
	{
		//console.log('set markers', value, this.getClassName());
		this.clearMarkers();
		this.setPropStoreFieldValue('attachedMarkers', value);
		this._updateAttachedMarkersOwner();
		this._updateAttachedMarkersParent();
		//console.log('after set', this.getAttachedMarkers());
	}
});
/*
// if true, position of newly added marker will be set automatically
ClassEx.defineProp(Kekule.ChemObject, 'autoSetAttachedMarkerPos',
{
	'dataType': DataType.BOOL, 'scope':  Class.PropertyScope.PUBLISHED
});
*/


})();</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="Class.html">Class</a></li><li><a href="ClassEx.html">ClassEx</a></li><li><a href="JsonObjSerializer.html">JsonObjSerializer</a></li><li><a href="Kekule.AbstractAtom.html">AbstractAtom</a></li><li><a href="Kekule.AbstractConfigs.html">AbstractConfigs</a></li><li><a href="Kekule.ArrayUtils.html">ArrayUtils</a></li><li><a href="Kekule.Atom.html">Atom</a></li><li><a href="Kekule.AtomType.html">AtomType</a></li><li><a href="Kekule.BaseStructureConnector.html">BaseStructureConnector</a></li><li><a href="Kekule.BaseStructureNode.html">BaseStructureNode</a></li><li><a href="Kekule.Bond.html">Bond</a></li><li><a href="Kekule.BondForm.html">BondForm</a></li><li><a href="Kekule.BondFormFactory.html">BondFormFactory</a></li><li><a href="Kekule.BondOrder.html">BondOrder</a></li><li><a href="Kekule.BondStereo.html">BondStereo</a></li><li><a href="Kekule.BondType.html">BondType</a></li><li><a href="Kekule.BoxUtils.html">BoxUtils</a></li><li><a href="Kekule.ChemMarker.BaseMarker.html">BaseMarker</a></li><li><a href="Kekule.ChemMarker.Charge.html">Charge</a></li><li><a href="Kekule.ChemMarker.ChemPropertyMarker.html">ChemPropertyMarker</a></li><li><a href="Kekule.ChemMarker.Radical.html">Radical</a></li><li><a href="Kekule.ChemMarker.UnbondedElectronSet.html">UnbondedElectronSet</a></li><li><a href="Kekule.ChemStructureBuilder.html">ChemStructureBuilder</a></li><li><a href="Kekule.ChemStructureConnector.html">ChemStructureConnector</a></li><li><a href="Kekule.ChemStructureNode.html">ChemStructureNode</a></li><li><a href="Kekule.ChemStructureNodeFactory.html">ChemStructureNodeFactory</a></li><li><a href="Kekule.ChemStructureNodeLabels.html">ChemStructureNodeLabels</a></li><li><a href="Kekule.ChemStructureObjectGroup.html">ChemStructureObjectGroup</a></li><li><a href="Kekule.ChemStructureUtils.html">ChemStructureUtils</a></li><li><a href="Kekule.ChemTextAnalyzer.html">ChemTextAnalyzer</a></li><li><a href="Kekule.ClassUtils.html">ClassUtils</a></li><li><a href="Kekule.CompositeMolecule.html">CompositeMolecule</a></li><li><a href="Kekule.ConfigPresetMap.html">ConfigPresetMap</a></li><li><a href="Kekule.ContentBlock.html">ContentBlock</a></li><li><a href="Kekule.CoordUtils.html">CoordUtils</a></li><li><a href="Kekule.DomHelper.html">DomHelper</a></li><li><a href="Kekule.ElectronSet.html">ElectronSet</a></li><li><a href="Kekule.Element.html">Element</a></li><li><a href="Kekule.FactoryUtils.html">FactoryUtils</a></li><li><a href="Kekule.FormulaUtils.html">FormulaUtils</a></li><li><a href="Kekule.GeometryUtils.html">GeometryUtils</a></li><li><a href="Kekule.Glyph.AddSymbol.html">AddSymbol</a></li><li><a href="Kekule.Glyph.Arc.html">Arc</a></li><li><a href="Kekule.Glyph.ArrowSide.html">ArrowSide</a></li><li><a href="Kekule.Glyph.ArrowType.html">ArrowType</a></li><li><a href="Kekule.Glyph.Base.html">Base</a></li><li><a href="Kekule.Glyph.HeatSymbol.html">HeatSymbol</a></li><li><a href="Kekule.Glyph.NodeType.html">NodeType</a></li><li><a href="Kekule.Glyph.PathGlyph.html">PathGlyph</a></li><li><a href="Kekule.Glyph.PathGlyphArcConnector.html">PathGlyphArcConnector</a></li><li><a href="Kekule.Glyph.PathGlyphArcConnectorControlNode.html">PathGlyphArcConnectorControlNode</a></li><li><a href="Kekule.Glyph.PathGlyphConnector.html">PathGlyphConnector</a></li><li><a href="Kekule.Glyph.PathGlyphConnectorControlNode.html">PathGlyphConnectorControlNode</a></li><li><a href="Kekule.Glyph.PathGlyphNode.html">PathGlyphNode</a></li><li><a href="Kekule.Glyph.PathType.html">PathType</a></li><li><a href="Kekule.Glyph.Polygon.html">Polygon</a></li><li><a href="Kekule.Glyph.StraightLine.html">StraightLine</a></li><li><a href="Kekule.HybridizationType.html">HybridizationType</a></li><li><a href="Kekule.ImageBlock.html">ImageBlock</a></li><li><a href="Kekule.Isotope.html">Isotope</a></li><li><a href="Kekule.IsotopeFactory.html">IsotopeFactory</a></li><li><a href="Kekule.MatrixUtils.html">MatrixUtils</a></li><li><a href="Kekule.MolecularFormula.html">MolecularFormula</a></li><li><a href="Kekule.Molecule.html">Molecule</a></li><li><a href="Kekule.MoleculeGroup.html">MoleculeGroup</a></li><li><a href="Kekule.MoleculeList.html">MoleculeList</a></li><li><a href="Kekule.NumUtils.html">NumUtils</a></li><li><a href="Kekule.ObjUtils.html">ObjUtils</a></li><li><a href="Kekule.PredefinedResLoader.html">PredefinedResLoader</a></li><li><a href="Kekule.PredefinedResReferer.html">PredefinedResReferer</a></li><li><a href="Kekule.Pseudoatom.html">Pseudoatom</a></li><li><a href="Kekule.PseudoatomType.html">PseudoatomType</a></li><li><a href="Kekule.RadicalOrder.html">RadicalOrder</a></li><li><a href="Kekule.Reaction.html">Reaction</a></li><li><a href="Kekule.ReactionComponent.html">ReactionComponent</a></li><li><a href="Kekule.ReactionList.html">ReactionList</a></li><li><a href="Kekule.ReactionRole.html">ReactionRole</a></li><li><a href="Kekule.RectUtils.html">RectUtils</a></li><li><a href="Kekule.RoleMapUtils.html">RoleMapUtils</a></li><li><a href="Kekule.StructureConnectionTable.html">StructureConnectionTable</a></li><li><a href="Kekule.StructureFragment.html">StructureFragment</a></li><li><a href="Kekule.StructureFragmentGroup.html">StructureFragmentGroup</a></li><li><a href="Kekule.StructureFragmentShadow.html">StructureFragmentShadow</a></li><li><a href="Kekule.StrUtils.html">StrUtils</a></li><li><a href="Kekule.SubGroup.html">SubGroup</a></li><li><a href="Kekule.TextBlock.html">TextBlock</a></li><li><a href="Kekule.TextLinesBuffer.html">TextLinesBuffer</a></li><li><a href="Kekule.TokenAnalyzer.html">TokenAnalyzer</a></li><li><a href="Kekule.UnbondedElectronSet.html">UnbondedElectronSet</a></li><li><a href="Kekule.ValenceUtils.html">ValenceUtils</a></li><li><a href="Kekule.VariableAtom.html">VariableAtom</a></li><li><a href="Kekule.ZoomUtils.html">ZoomUtils</a></li><li><a href="ObjectEx.html">ObjectEx</a></li><li><a href="ObjSerializerFactory.html">ObjSerializerFactory</a></li><li><a href="XmlObjSerializer.html">XmlObjSerializer</a></li><li><a href="XmlUtility.html">XmlUtility</a></li></ul><h3>Events</h3><ul><li><a href="Kekule.AbstractAtom.html#event:structureChange">structureChange</a></li><li><a href="Kekule.AbstractConfigs.html#event:change">change</a></li><li><a href="Kekule.AbstractConfigs.html#event:finalize">finalize</a></li><li><a href="Kekule.AbstractConfigs.html#event:propValueSet">propValueSet</a></li><li><a href="Kekule.Atom.html#event:structureChange">structureChange</a></li><li><a href="Kekule.BaseStructureConnector.html#event:structureChange">structureChange</a></li><li><a href="Kekule.BaseStructureNode.html#event:structureChange">structureChange</a></li><li><a href="Kekule.Bond.html#event:structureChange">structureChange</a></li><li><a href="Kekule.ChemStructureBuilder.html#event:change">change</a></li><li><a href="Kekule.ChemStructureBuilder.html#event:finalize">finalize</a></li><li><a href="Kekule.ChemStructureBuilder.html#event:propValueSet">propValueSet</a></li><li><a href="Kekule.ChemStructureConnector.html#event:structureChange">structureChange</a></li><li><a href="Kekule.ChemStructureNode.html#event:structureChange">structureChange</a></li><li><a href="Kekule.ChemStructureObject.html#event:structureChange">structureChange</a></li><li><a href="Kekule.ChemStructureObjectGroup.html#event:structureChange">structureChange</a></li><li><a href="Kekule.ChemTextAnalyzer.html#event:change">change</a></li><li><a href="Kekule.ChemTextAnalyzer.html#event:finalize">finalize</a></li><li><a href="Kekule.ChemTextAnalyzer.html#event:propValueSet">propValueSet</a></li><li><a href="Kekule.CompositeMolecule.html#event:structureChange">structureChange</a></li><li><a href="Kekule.ConfigPresetMap.html#event:change">change</a></li><li><a href="Kekule.ConfigPresetMap.html#event:finalize">finalize</a></li><li><a href="Kekule.ConfigPresetMap.html#event:propValueSet">propValueSet</a></li><li><a href="Kekule.DomHelper.html#event:change">change</a></li><li><a href="Kekule.DomHelper.html#event:finalize">finalize</a></li><li><a href="Kekule.DomHelper.html#event:propValueSet">propValueSet</a></li><li><a href="Kekule.Glyph.PathGlyphArcConnector.html#event:structureChange">structureChange</a></li><li><a href="Kekule.Glyph.PathGlyphArcConnectorControlNode.html#event:structureChange">structureChange</a></li><li><a href="Kekule.Glyph.PathGlyphConnector.html#event:structureChange">structureChange</a></li><li><a href="Kekule.Glyph.PathGlyphConnectorControlNode.html#event:structureChange">structureChange</a></li><li><a href="Kekule.Glyph.PathGlyphNode.html#event:structureChange">structureChange</a></li><li><a href="Kekule.MolecularFormula.html#event:change">change</a></li><li><a href="Kekule.MolecularFormula.html#event:finalize">finalize</a></li><li><a href="Kekule.MolecularFormula.html#event:propValueSet">propValueSet</a></li><li><a href="Kekule.Molecule.html#event:structureChange">structureChange</a></li><li><a href="Kekule.MoleculeGroup.html#event:structureChange">structureChange</a></li><li><a href="Kekule.PredefinedResLoader.html#event:change">change</a></li><li><a href="Kekule.PredefinedResLoader.html#event:finalize">finalize</a></li><li><a href="Kekule.PredefinedResLoader.html#event:propValueSet">propValueSet</a></li><li><a href="Kekule.Pseudoatom.html#event:structureChange">structureChange</a></li><li><a href="Kekule.StructureConnectionTable.html#event:change">change</a></li><li><a href="Kekule.StructureConnectionTable.html#event:finalize">finalize</a></li><li><a href="Kekule.StructureConnectionTable.html#event:propValueSet">propValueSet</a></li><li><a href="Kekule.StructureFragment.html#event:structureChange">structureChange</a></li><li><a href="Kekule.StructureFragmentGroup.html#event:structureChange">structureChange</a></li><li><a href="Kekule.StructureFragmentShadow.html#event:change">change</a></li><li><a href="Kekule.StructureFragmentShadow.html#event:finalize">finalize</a></li><li><a href="Kekule.StructureFragmentShadow.html#event:propValueSet">propValueSet</a></li><li><a href="Kekule.SubGroup.html#event:structureChange">structureChange</a></li><li><a href="Kekule.TextLinesBuffer.html#event:change">change</a></li><li><a href="Kekule.TextLinesBuffer.html#event:finalize">finalize</a></li><li><a href="Kekule.TextLinesBuffer.html#event:propValueSet">propValueSet</a></li><li><a href="Kekule.TokenAnalyzer.html#event:change">change</a></li><li><a href="Kekule.TokenAnalyzer.html#event:finalize">finalize</a></li><li><a href="Kekule.TokenAnalyzer.html#event:propValueSet">propValueSet</a></li><li><a href="Kekule.VariableAtom.html#event:structureChange">structureChange</a></li><li><a href="ObjectEx.html#event:change">change</a></li><li><a href="ObjectEx.html#event:finalize">finalize</a></li><li><a href="ObjectEx.html#event:propValueSet">propValueSet</a></li></ul><h3>Namespaces</h3><ul><li><a href="Kekule.ChemMarker.html">ChemMarker</a></li><li><a href="Kekule.Glyph.html">Glyph</a></li></ul><h3>Global</h3><ul><li><a href="global.html#jsonToValue">jsonToValue</a></li><li><a href="global.html#loadObj">loadObj</a></li><li><a href="global.html#saveObj">saveObj</a></li><li><a href="global.html#valueToJson">valueToJson</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-dev</a> on Mon Nov 26 2018 21:08:32 GMT+0800 (CST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
